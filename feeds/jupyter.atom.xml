<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Notes on Data Science - Jupyter</title><link href="https://stefanschmidt.github.io/" rel="alternate"></link><link href="https://stefanschmidt.github.io/feeds/jupyter.atom.xml" rel="self"></link><id>https://stefanschmidt.github.io/</id><updated>2024-04-02T00:00:00+02:00</updated><entry><title>An Iterative Workflow for Jupyter Notebook</title><link href="https://stefanschmidt.github.io/an-iterative-workflow-for-jupyter-notebook.html" rel="alternate"></link><published>2024-04-02T00:00:00+02:00</published><updated>2024-04-02T00:00:00+02:00</updated><author><name>Stefan</name></author><id>tag:stefanschmidt.github.io,2024-04-02:/an-iterative-workflow-for-jupyter-notebook.html</id><summary type="html">&lt;p&gt;Inspecting a data set is usually not a linear process, but involves iterative refinement of the initial assumptions and question. One might have an initial question but after taking a look at the data set realize that it requires multiple preprocessing steps before it can be used to address the â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;Inspecting a data set is usually not a linear process, but involves iterative refinement of the initial assumptions and question. One might have an initial question but after taking a look at the data set realize that it requires multiple preprocessing steps before it can be used to address the question.&lt;/p&gt;
&lt;p&gt;Jupyter Notebook may be very nice for presenting the &lt;em&gt;results&lt;/em&gt; of a data analysis, but using it for an iterative workflow feels not nearly as productive as working on the command-line interface with the Python interpreter, which leaves the question if there is some room for improvement.&lt;/p&gt;
&lt;p&gt;One thing I noticed that eats up &lt;em&gt;a lot&lt;/em&gt; of time while working with Jupyter Notebook is scrolling through the notebook to locate something in a cell. This can be a snippet of code, some documentation or an error message.&lt;/p&gt;
&lt;h1&gt;More keyboard, less mouse&lt;/h1&gt;
&lt;p&gt;One obvious way to increase productivity is to to work with the keyboard as much as possible, not touching the mouse unless absolutely necessary. Reminding of Vims modes, Jupyter Notebook allows switching between edit mode and command mode allowing to move upwards and downwards, insert and remove cells, etc. and has keyboard shortcuts at least for some menu entries.&lt;/p&gt;
&lt;h1&gt;Less scrolling in error messages&lt;/h1&gt;
&lt;p&gt;Another thing I noticed is that error messages feel &lt;em&gt;very&lt;/em&gt; verbose compared to the command-line interface. To see the actual exception one often needs to repeatedly scroll downwards. When comparing the form of presentation to the Python command-line interface I noticed that the error messages not only include the stack trace but also the context of each function call. This may certainly be useful if one is debugging or developing an API, but otherwise it is often merely a form of distraction. Having less verbose error messages would mean spending less time on scrolling through the notebook.&lt;/p&gt;
&lt;p&gt;Luckily the IPython kernel in Jupyter Notebook provides several levels of verbosity for exceptions: &lt;code&gt;Plain&lt;/code&gt;, &lt;code&gt;Context&lt;/code&gt;, &lt;code&gt;Verbose&lt;/code&gt; and &lt;code&gt;Minimal&lt;/code&gt;. The default is &lt;code&gt;Context&lt;/code&gt; which is even more verbose than the default in the Python Interpreter. &lt;code&gt;Minimal&lt;/code&gt; ommits the stack trace, showing just the actual exception.&lt;/p&gt;
&lt;p&gt;To set the exception verbosity in Jupyter for an individual notebook one can use &lt;a href="https://ipython.readthedocs.io/en/stable/interactive/magics.html#magic-xmode"&gt;&lt;code&gt;xmode&lt;/code&gt;&lt;/a&gt;. There is also a configuration setting &lt;a href="https://ipython.readthedocs.io/en/stable/config/options/kernel.html#configtrait-InteractiveShell.xmode"&gt;&lt;code&gt;c.InteractiveShell.xmode&lt;/code&gt;&lt;/a&gt; that can be enabled in &lt;a href="https://ipython.readthedocs.io/en/stable/config/intro.html"&gt;&lt;code&gt;ipython_kernel_config.py&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In comparison the Python interpreter allows to set the verbosity either on the command-line with &lt;a href="https://docs.python.org/3/using/cmdline.html#cmdoption-v"&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/a&gt;, by setting the environment variable &lt;a href="https://docs.python.org/3/using/cmdline.html#envvar-PYTHONVERBOSE"&gt;&lt;code&gt;PYTHONVERBOSE&lt;/code&gt;&lt;/a&gt; or in the interpreter using &lt;a href="https://docs.python.org/3/library/sys.html#sys.tracebacklimit"&gt;&lt;code&gt;sys.tracebacklimit&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Connect the terminal with the browser&lt;/h1&gt;
&lt;p&gt;Minimizing the number of mouse interactions by using keyboard shortcuts and reducing the scrolling through error messages by making them less verbose certainly has some potential to make an iterative workflow in Juypter Notebook more productive.&lt;/p&gt;
&lt;p&gt;A different approach would be have an integration of the Python interpreter in the terminal and the notebook in the browser allowing to seamlessly switch back and forth. Any variable created in the notebook should be available in the Python interpreter in the terminal and vice-versa. While Jupyter &lt;em&gt;does&lt;/em&gt; allow to open a console within the browser it does not provide the same user experience as the Python interpreter in a terminal window.&lt;/p&gt;
&lt;p&gt;Connecting the original Python interpreter to the kernel of an already running notebook is certainly technically possible but it seems there is no convenient built-in method that wraps things nicely up.&lt;/p&gt;
&lt;p&gt;It is however possible to connect an IPython interpreter in the terminal with the kernel of an already running notebook using either &lt;code&gt;jupyter console --existing&lt;/code&gt; to connect to the most recent kernel that was started or &lt;code&gt;jupyter console --existing kernel.json&lt;/code&gt; to connect to a specific kernel. To get the file name of a kernel from an already running notebook one can use &lt;a href="https://ipython.readthedocs.io/en/stable/overview.html"&gt;&lt;code&gt;%connect_info&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While the IPython interpreter is supposed to provide an improved user experience I prefer the original Python interpreter. A workaround might be to adjust the behaviour of the IPython interpreter to more closely align with the original Python interpreter but I have not investigated if that is possible. Nonetheless being able to connect from the terminal to an already running notebook in Jupyter is a promising productivity gain.&lt;/p&gt;</content><category term="Jupyter"></category></entry></feed>